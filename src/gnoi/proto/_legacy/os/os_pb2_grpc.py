# Generated by the gRPC Python protocol compiler plugin. DO NOT EDIT!
"""Client and server classes corresponding to protobuf-defined services."""
import grpc

from gnoi.proto._legacy.os import os_pb2 as gnoi_dot_proto_dot___legacy_dot_os_dot_os__pb2


class OSStub(object):
    """The OS service provides an interface for OS installation on a Target. The
    Client progresses through 3 RPCs:
    1) Installation - provide the Target with the OS package.
    2) Activation - activate an installed OS package.
    3) Verification - verify that the Activation was successful.

    Dual Supervisor Target is supported, where the above process is executed once
    for each Supervisor.

    Note that certain platforms may have particular approaches to upgrade the
    firmware of specific components, eg., power supply units, etc.. In addition,
    platforms may have processes to apply patches to the running OS. Handling
    these exceptions introduces extra complexities. For Targets that implement
    this service, component firmware upgrade or OS patching MUST be embedded
    within an OS upgrade.
    """

    def __init__(self, channel):
        """Constructor.

        Args:
            channel: A grpc.Channel.
        """
        self.Install = channel.stream_stream(
                '/gnoi.os.OS/Install',
                request_serializer=gnoi_dot_proto_dot___legacy_dot_os_dot_os__pb2.InstallRequest.SerializeToString,
                response_deserializer=gnoi_dot_proto_dot___legacy_dot_os_dot_os__pb2.InstallResponse.FromString,
                )
        self.Activate = channel.unary_unary(
                '/gnoi.os.OS/Activate',
                request_serializer=gnoi_dot_proto_dot___legacy_dot_os_dot_os__pb2.ActivateRequest.SerializeToString,
                response_deserializer=gnoi_dot_proto_dot___legacy_dot_os_dot_os__pb2.ActivateResponse.FromString,
                )
        self.Verify = channel.unary_unary(
                '/gnoi.os.OS/Verify',
                request_serializer=gnoi_dot_proto_dot___legacy_dot_os_dot_os__pb2.VerifyRequest.SerializeToString,
                response_deserializer=gnoi_dot_proto_dot___legacy_dot_os_dot_os__pb2.VerifyResponse.FromString,
                )


class OSServicer(object):
    """The OS service provides an interface for OS installation on a Target. The
    Client progresses through 3 RPCs:
    1) Installation - provide the Target with the OS package.
    2) Activation - activate an installed OS package.
    3) Verification - verify that the Activation was successful.

    Dual Supervisor Target is supported, where the above process is executed once
    for each Supervisor.

    Note that certain platforms may have particular approaches to upgrade the
    firmware of specific components, eg., power supply units, etc.. In addition,
    platforms may have processes to apply patches to the running OS. Handling
    these exceptions introduces extra complexities. For Targets that implement
    this service, component firmware upgrade or OS patching MUST be embedded
    within an OS upgrade.
    """

    def Install(self, request_iterator, context):
        """Install transfers an OS package into the Target. No concurrent Install RPCs
        MUST be allowed to the same Target.

        The OS package file format is platform dependent. The platform MUST
        validate that the OS package that is supplied is valid and bootable. This
        SHOULD include a hash check against a known good hash. It is recommended
        that the hash is embedded in the OS package.

        The Target manages its own persistent storage, and OS installation process.
        It stores a set of distinct OS packages, and always proactively frees up
        space for incoming new OS packages. It is guaranteed that the Target always
        has enough space for a valid incoming OS package. The currently running OS
        packages MUST never be removed. The Client MUST expect that the last
        successfully installed package is available.

        The Install RPC allows the Client to specify the OS package version. If
        the Target already has an OS package with the same version then there is no
        need to transfer the OS package to the Target. If the Target does not have
        an OS package with the same version, then the OS package is copied.

        Scenario 1 - When the Target already has the OS package:

        Client :--------------|--------------> Target
        TransferRequest -->
        <-- [Validated|InstallError]


        Scenario 2 - When the Target does not have the OS package:

        Client :--------------|--------------> Target
        TransferRequest -->
        <-- [TransferReady|InstallError]
        transfer_content  -->
        ...
        <-- [TransferProgress|InstallError]
        ...
        TransferEnd -->
        <-- [Validated|InstallError]

        On a dual Supervisor Target, only the Active Supervisor runs this gNOI
        Service. The Install RPC applies to the Active Supervisor unless
        InstallRequest->TransferRequest->standby_supervisor is set, in which case
        it applies to the Standby Supervisor. One Install RPC is required for each
        Supervisor. The Supervisor order of package installation MUST not be fixed.

        The Target MUST always attempt to copy the OS package between Supervisors
        first before accepting the transfer from the Client. The syncing progress
        is reported to the client with InstallResponse->SyncProgress messages.

        If a switchover is triggered during the Install RPC, the RPC MUST
        immediately abort with Error->type->UNEXPECTED_SWITCHOVER.

        Scenario 3 - When both Supervisors already have the OS package, regardless
        of the value in Start.standby_supervisor:

        Client :--------------|--------------> Target
        TransferRequest -->
        <-- [Validated|InstallError]


        Scenario 4 - When one of the Supervisors already has the OS package but the
        other Supervisor is the target of the Install:

        Client :--------------|--------------> Target
        TransferRequest -->
        <-- [SyncProgress|InstallError]
        ...
        <-- [Validated|InstallError]


        Scenario 5 - When neither of the two Supervisors has the OS package:

        Client :--------------|--------------> Target
        TransferRequest -->
        <-- [TransferReady|InstallError]
        transfer_content  -->
        ...
        <-- [TransferProgress|InstallError]
        ...
        TransferEnd -->
        <-- [Validated|InstallError]

        """
        context.set_code(grpc.StatusCode.UNIMPLEMENTED)
        context.set_details('Method not implemented!')
        raise NotImplementedError('Method not implemented!')

    def Activate(self, request, context):
        """Activate sets the requested OS version as the version which is used at the
        next reboot, and reboots the Target. When booting the requested OS version
        fails, the Target recovers by booting the previously running OS package.
        """
        context.set_code(grpc.StatusCode.UNIMPLEMENTED)
        context.set_details('Method not implemented!')
        raise NotImplementedError('Method not implemented!')

    def Verify(self, request, context):
        """Verify checks the running OS version. This RPC may be called multiple times
        while the Target boots, until successful.
        """
        context.set_code(grpc.StatusCode.UNIMPLEMENTED)
        context.set_details('Method not implemented!')
        raise NotImplementedError('Method not implemented!')


def add_OSServicer_to_server(servicer, server):
    rpc_method_handlers = {
            'Install': grpc.stream_stream_rpc_method_handler(
                    servicer.Install,
                    request_deserializer=gnoi_dot_proto_dot___legacy_dot_os_dot_os__pb2.InstallRequest.FromString,
                    response_serializer=gnoi_dot_proto_dot___legacy_dot_os_dot_os__pb2.InstallResponse.SerializeToString,
            ),
            'Activate': grpc.unary_unary_rpc_method_handler(
                    servicer.Activate,
                    request_deserializer=gnoi_dot_proto_dot___legacy_dot_os_dot_os__pb2.ActivateRequest.FromString,
                    response_serializer=gnoi_dot_proto_dot___legacy_dot_os_dot_os__pb2.ActivateResponse.SerializeToString,
            ),
            'Verify': grpc.unary_unary_rpc_method_handler(
                    servicer.Verify,
                    request_deserializer=gnoi_dot_proto_dot___legacy_dot_os_dot_os__pb2.VerifyRequest.FromString,
                    response_serializer=gnoi_dot_proto_dot___legacy_dot_os_dot_os__pb2.VerifyResponse.SerializeToString,
            ),
    }
    generic_handler = grpc.method_handlers_generic_handler(
            'gnoi.os.OS', rpc_method_handlers)
    server.add_generic_rpc_handlers((generic_handler,))


 # This class is part of an EXPERIMENTAL API.
class OS(object):
    """The OS service provides an interface for OS installation on a Target. The
    Client progresses through 3 RPCs:
    1) Installation - provide the Target with the OS package.
    2) Activation - activate an installed OS package.
    3) Verification - verify that the Activation was successful.

    Dual Supervisor Target is supported, where the above process is executed once
    for each Supervisor.

    Note that certain platforms may have particular approaches to upgrade the
    firmware of specific components, eg., power supply units, etc.. In addition,
    platforms may have processes to apply patches to the running OS. Handling
    these exceptions introduces extra complexities. For Targets that implement
    this service, component firmware upgrade or OS patching MUST be embedded
    within an OS upgrade.
    """

    @staticmethod
    def Install(request_iterator,
            target,
            options=(),
            channel_credentials=None,
            call_credentials=None,
            compression=None,
            wait_for_ready=None,
            timeout=None,
            metadata=None):
        return grpc.experimental.stream_stream(request_iterator, target, '/gnoi.os.OS/Install',
            gnoi_dot_proto_dot___legacy_dot_os_dot_os__pb2.InstallRequest.SerializeToString,
            gnoi_dot_proto_dot___legacy_dot_os_dot_os__pb2.InstallResponse.FromString,
            options, channel_credentials,
            call_credentials, compression, wait_for_ready, timeout, metadata)

    @staticmethod
    def Activate(request,
            target,
            options=(),
            channel_credentials=None,
            call_credentials=None,
            compression=None,
            wait_for_ready=None,
            timeout=None,
            metadata=None):
        return grpc.experimental.unary_unary(request, target, '/gnoi.os.OS/Activate',
            gnoi_dot_proto_dot___legacy_dot_os_dot_os__pb2.ActivateRequest.SerializeToString,
            gnoi_dot_proto_dot___legacy_dot_os_dot_os__pb2.ActivateResponse.FromString,
            options, channel_credentials,
            call_credentials, compression, wait_for_ready, timeout, metadata)

    @staticmethod
    def Verify(request,
            target,
            options=(),
            channel_credentials=None,
            call_credentials=None,
            compression=None,
            wait_for_ready=None,
            timeout=None,
            metadata=None):
        return grpc.experimental.unary_unary(request, target, '/gnoi.os.OS/Verify',
            gnoi_dot_proto_dot___legacy_dot_os_dot_os__pb2.VerifyRequest.SerializeToString,
            gnoi_dot_proto_dot___legacy_dot_os_dot_os__pb2.VerifyResponse.FromString,
            options, channel_credentials,
            call_credentials, compression, wait_for_ready, timeout, metadata)
