# Generated by the protocol buffer compiler.  DO NOT EDIT!
# sources: github.com/openconfig/gnoi/file/file.proto
# plugin: python-betterproto
from dataclasses import dataclass
from typing import AsyncIterable, AsyncIterator, Iterable, List, Optional, Union

import betterproto
import grpclib

from .. import common as _common__
from .. import types as _types__


@dataclass
class PutRequest(betterproto.Message):
    """
    A PutRequest is used to send data to be written on a file on the target.
    The initial message contains an Open message. The Open message contains
    information name of the file and the file's permisssions. The remote_file
    must be an absolute path. If remote_file already exists on the target, it
    is overwritten, otherwise it is created. If the path to remote_file doesn't
    exist it will be created. The contents to be written are streamed through
    multiple messages using the contents field. Each message may contain up to
    64KB of data. The final message of the RPC contains the hash of the file
    contents.
    """

    open: "PutRequestDetails" = betterproto.message_field(1, group="request")
    contents: bytes = betterproto.bytes_field(2, group="request")
    hash: _types__.HashType = betterproto.message_field(3, group="request")


@dataclass
class PutRequestDetails(betterproto.Message):
    remote_file: str = betterproto.string_field(1)
    # Permissions are represented as the octal format of standard UNIX file
    # permissions. ex. 775: user read/write/execute, group read/write/execute,
    # global read/execute.
    permissions: int = betterproto.uint32_field(2)


@dataclass
class PutResponse(betterproto.Message):
    pass


@dataclass
class GetRequest(betterproto.Message):
    """
    A GetRequest specifies the remote_file to be streamed back to the caller.
    The remote_file must be an absolute path to an existing file.
    """

    remote_file: str = betterproto.string_field(1)


@dataclass
class GetResponse(betterproto.Message):
    """
    A GetResponse either contains the next set of bytes read from the file or,
    as the last message, the hash of the data.
    """

    contents: bytes = betterproto.bytes_field(1, group="response")
    hash: _types__.HashType = betterproto.message_field(2, group="response")


@dataclass
class TransferToRemoteRequest(betterproto.Message):
    """
    A TransferToRemoteRequest specifies the local path to transfer to and the
    details on where to transfer the data from. The local_path must be an
    absolute path to the file.
    """

    local_path: str = betterproto.string_field(1)
    # Details to download the remote_file being requested to a remote location.
    remote_download: _common__.RemoteDownload = betterproto.message_field(2)


@dataclass
class TransferToRemoteResponse(betterproto.Message):
    """
    A TransferToRemoteResponse contains the hash of the data transferred.
    """

    hash: _types__.HashType = betterproto.message_field(1)


@dataclass
class StatRequest(betterproto.Message):
    """StatRequest will list files at the provided path."""

    path: str = betterproto.string_field(1)


@dataclass
class StatResponse(betterproto.Message):
    """StatResponse contains list of stat info of the provided path."""

    stats: List["StatInfo"] = betterproto.message_field(1)


@dataclass
class StatInfo(betterproto.Message):
    """StatInfo provides a file system information about a particular path."""

    path: str = betterproto.string_field(1)
    last_modified: int = betterproto.uint64_field(2)
    # Permissions are represented as the octal format of standard UNIX file
    # permissions. ex. 775: user read/write/execute, group read/write/execute,
    # global read/execute.
    permissions: int = betterproto.uint32_field(3)
    size: int = betterproto.uint64_field(4)
    # Default file creation mask. Represented as the octal format of standard
    # UNIX mask.
    umask: int = betterproto.uint32_field(5)


@dataclass
class RemoveRequest(betterproto.Message):
    """A RemoveRequest specifies a file to be removed from the target."""

    remote_file: str = betterproto.string_field(1)


@dataclass
class RemoveResponse(betterproto.Message):
    pass


class FileStub(betterproto.ServiceStub):
    async def get(self, *, remote_file: str = "") -> AsyncIterator[GetResponse]:
        """
        Get reads and streams the contents of a file from the target. The file
        is streamed by sequential messages, each containing up to 64KB of data.
        A final message is sent prior to closing the stream that contains the
        hash of the data sent. An error is returned if the file does not exist
        or there was an error reading the file.
        """

        request = GetRequest()
        request.remote_file = remote_file

        async for response in self._unary_stream(
            "/gnoi.file.File/Get", request, GetResponse,
        ):
            yield response

    async def transfer_to_remote(
        self,
        *,
        local_path: str = "",
        remote_download: Optional[_common__.RemoteDownload] = None,
    ) -> TransferToRemoteResponse:
        """
        TransferToRemote transfers the contents of a file from the target to a
        specified remote location. The response contains the hash of the data
        transferred. An error is returned if the file does not exist, the file
        transfer fails, or if there was an error reading the file. This is a
        blocking call until the file transfer is complete.
        """

        request = TransferToRemoteRequest()
        request.local_path = local_path
        if remote_download is not None:
            request.remote_download = remote_download

        return await self._unary_unary(
            "/gnoi.file.File/TransferToRemote", request, TransferToRemoteResponse
        )

    async def put(
        self,
        request_iterator: Union[AsyncIterable["PutRequest"], Iterable["PutRequest"]],
    ) -> PutResponse:
        """
        Put streams data into a file on the target. The file is sent in
        sequential messages, each message containing up to 64KB of data. A
        final message must be sent that includes the hash of the data sent. An
        error is returned if the location does not exist or there is an error
        writing the data. If no checksum is received, the target must assume
        the operation is incomplete and remove the partially transmitted file.
        The target should initially write the file to a temporary location so a
        failure does not destroy the original file.
        """

        return await self._stream_unary(
            "/gnoi.file.File/Put", request_iterator, PutRequest, PutResponse
        )

    async def stat(self, *, path: str = "") -> StatResponse:
        """
        Stat returns metadata about a file on the target. An error is returned
        if the file does not exist of there is an error in accessing the
        metadata.
        """

        request = StatRequest()
        request.path = path

        return await self._unary_unary("/gnoi.file.File/Stat", request, StatResponse)

    async def remove(self, *, remote_file: str = "") -> RemoveResponse:
        """
        Remove removes the specified file from the target. An error is returned
        if the file does not exist, is a directory, or the remove operation
        encounters an error (e.g., permission denied).
        """

        request = RemoveRequest()
        request.remote_file = remote_file

        return await self._unary_unary(
            "/gnoi.file.File/Remove", request, RemoveResponse
        )
