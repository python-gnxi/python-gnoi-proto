# Generated by the protocol buffer compiler.  DO NOT EDIT!
# sources: github.com/openconfig/gnoi/system/system.proto
# plugin: python-betterproto
from dataclasses import dataclass
from typing import AsyncIterable, AsyncIterator, Dict, Iterable, List, Optional, Union

import betterproto
import grpclib

from .. import common as _common__
from .. import types as _types__


class RebootMethod(betterproto.Enum):
    """
    A RebootMethod determines what should be done with a target when a Reboot
    is requested.  Only the COLD method is required to be supported by all
    targets.  Methods the target does not support should result in failure. It
    is vendor defined if a WARM reboot is the same as an NSF reboot.
    """

    UNKNOWN = 0
    COLD = 1
    POWERDOWN = 2
    HALT = 3
    WARM = 4
    NSF = 5
    # FactoryReset.Start().
    POWERUP = 7


class TracerouteRequestL4Protocol(betterproto.Enum):
    ICMP = 0
    TCP = 1
    UDP = 2


class TracerouteResponseState(betterproto.Enum):
    DEFAULT = 0
    NONE = 1
    UNKNOWN = 2
    ICMP = 3
    HOST_UNREACHABLE = 4
    NETWORK_UNREACHABLE = 5
    PROTOCOL_UNREACHABLE = 6
    SOURCE_ROUTE_FAILED = 7
    FRAGMENTATION_NEEDED = 8
    PROHIBITED = 9
    PRECEDENCE_VIOLATION = 10
    PRECEDENCE_CUTOFF = 11


@dataclass
class SwitchControlProcessorRequest(betterproto.Message):
    control_processor: _types__.Path = betterproto.message_field(1)


@dataclass
class SwitchControlProcessorResponse(betterproto.Message):
    control_processor: _types__.Path = betterproto.message_field(1)
    version: str = betterproto.string_field(2)
    uptime: int = betterproto.int64_field(3)


@dataclass
class RebootRequest(betterproto.Message):
    """
    A RebootRequest requests the specified target be rebooted using the
    specified method aftar the specified delay.  Only the DEFAULT method with a
    delay of 0 is guaranteed to be accepted for all target types.
    """

    method: "RebootMethod" = betterproto.enum_field(1)
    # Delay in nanoseconds before issuing reboot.
    delay: int = betterproto.uint64_field(2)
    # Informational reason for the reboot.
    message: str = betterproto.string_field(3)
    # Optional sub-components to reboot.
    subcomponents: List[_types__.Path] = betterproto.message_field(4)
    # Force reboot if sanity checks fail. (ex. uncommited configuration)
    force: bool = betterproto.bool_field(5)


@dataclass
class RebootResponse(betterproto.Message):
    pass


@dataclass
class CancelRebootRequest(betterproto.Message):
    """
    A CancelRebootRequest requests the cancelation of any outstanding reboot
    request.
    """

    message: str = betterproto.string_field(1)
    subcomponents: List[_types__.Path] = betterproto.message_field(2)


@dataclass
class CancelRebootResponse(betterproto.Message):
    pass


@dataclass
class RebootStatusRequest(betterproto.Message):
    subcomponents: List[_types__.Path] = betterproto.message_field(1)


@dataclass
class RebootStatusResponse(betterproto.Message):
    active: bool = betterproto.bool_field(1)
    wait: int = betterproto.uint64_field(2)
    when: int = betterproto.uint64_field(3)
    reason: str = betterproto.string_field(4)
    count: int = betterproto.uint32_field(5)


@dataclass
class TimeRequest(betterproto.Message):
    """A TimeRequest requests the current time accodring to the target."""

    pass


@dataclass
class TimeResponse(betterproto.Message):
    time: int = betterproto.uint64_field(1)


@dataclass
class PingRequest(betterproto.Message):
    """
    A PingRequest describes the ping operation to perform.  Only the
    destination fields is required.  Any field not specified is set to a
    reasonable server specified value.  Not all fields are supported by all
    vendors. A count of 0 defaults to a vendor specified value, typically 5.  A
    count of -1 means continue until the RPC times out or is canceled. If the
    interval is -1 then a flood ping is issued. If the size is 0, the vendor
    default size will be used (typically 56 bytes).
    """

    destination: str = betterproto.string_field(1)
    source: str = betterproto.string_field(2)
    count: int = betterproto.int32_field(3)
    interval: int = betterproto.int64_field(4)
    wait: int = betterproto.int64_field(5)
    size: int = betterproto.int32_field(6)
    do_not_fragment: bool = betterproto.bool_field(7)
    do_not_resolve: bool = betterproto.bool_field(8)
    l3_protocol: _types__.L3Protocol = betterproto.enum_field(9)


@dataclass
class PingResponse(betterproto.Message):
    """
    A PingResponse represents either the reponse to a single ping packet (the
    bytes field is non-zero) or the summary statistics (sent is non-zero). For
    a single ping packet, time is the round trip time, in nanoseconds.  For
    summary statistics, it is the time spent by the ping operation.  The time
    is not always present in summary statistics.  The std_dev is not always
    present in summary statistics.
    """

    source: str = betterproto.string_field(1)
    time: int = betterproto.int64_field(2)
    sent: int = betterproto.int32_field(3)
    received: int = betterproto.int32_field(4)
    min_time: int = betterproto.int64_field(5)
    avg_time: int = betterproto.int64_field(6)
    max_time: int = betterproto.int64_field(7)
    std_dev: int = betterproto.int64_field(8)
    bytes: int = betterproto.int32_field(11)
    sequence: int = betterproto.int32_field(12)
    ttl: int = betterproto.int32_field(13)


@dataclass
class TracerouteRequest(betterproto.Message):
    """
    A TracerouteRequest describes the traceroute operation to perform.  Only
    the destination field is required.  Any field not specified is set to a
    reasonable server specified value.  Not all fields are supported by all
    vendors. If the hop_count is -1 the traceroute will continue forever.
    """

    source: str = betterproto.string_field(1)
    destination: str = betterproto.string_field(2)
    initial_ttl: int = betterproto.uint32_field(3)
    max_ttl: int = betterproto.int32_field(4)
    wait: int = betterproto.int64_field(5)
    do_not_fragment: bool = betterproto.bool_field(6)
    do_not_resolve: bool = betterproto.bool_field(7)
    l3_protocol: _types__.L3Protocol = betterproto.enum_field(8)
    l4_protocol: "TracerouteRequestL4Protocol" = betterproto.enum_field(9)


@dataclass
class TracerouteResponse(betterproto.Message):
    """
    A TraceRouteResponse contains the result of a single traceoute packet.
    There may be an optional initial response that provides information about
    the traceroute request itself and contains at least one of the fields in
    the the initial block of fields and none of the fields following that
    block.  All subsequent responses should not contain any of these fields.
    Typically multiple responses are received for each hop, as the packets are
    received. The mpls field maps names to values.  Example names include
    "Label", "CoS", "TTL", "S", and "MRU". [Perhaps we should list the
    canonical names that must be used when applicable].
    """

    # The following fields are only filled in for the first message. If any of
    # these fields are specified, all fields following this block are left
    # unspecified.
    destination_name: str = betterproto.string_field(1)
    destination_address: str = betterproto.string_field(2)
    hops: int = betterproto.int32_field(3)
    packet_size: int = betterproto.int32_field(4)
    # The following fields provide the disposition of a single traceroute packet.
    hop: int = betterproto.int32_field(5)
    address: str = betterproto.string_field(6)
    name: str = betterproto.string_field(7)
    rtt: int = betterproto.int64_field(8)
    state: "TracerouteResponseState" = betterproto.enum_field(9)
    icmp_code: int = betterproto.int32_field(10)
    mpls: Dict[str, str] = betterproto.map_field(
        11, betterproto.TYPE_STRING, betterproto.TYPE_STRING
    )
    as_path: List[int] = betterproto.int32_field(12)


@dataclass
class Package(betterproto.Message):
    """Package defines a single package file to be placed on the target."""

    # Destination path and filename of the package.
    filename: str = betterproto.string_field(1)
    # Version of the package. (vendor internal name)
    version: str = betterproto.string_field(4)
    # Indicates that the package should be made active after receipt on the
    # device. For system image packages, the new image is expected to be active
    # after a reboot.
    activate: bool = betterproto.bool_field(5)
    # Details for the device to download the package from a remote location.
    remote_download: _common__.RemoteDownload = betterproto.message_field(6)


@dataclass
class SetPackageRequest(betterproto.Message):
    """
    SetPackageRequest will place the package onto the target and optionally
    mark it as the next bootable image. The initial message must be a package
    message containing the filename and information about the file. Following
    the initial message the contents are then streamed in maximum 64k chunks.
    The final message must be a hash message contains the hash of the file
    contents.
    """

    package: "Package" = betterproto.message_field(1, group="request")
    contents: bytes = betterproto.bytes_field(2, group="request")
    hash: _types__.HashType = betterproto.message_field(3, group="request")


@dataclass
class SetPackageResponse(betterproto.Message):
    pass


class SystemStub(betterproto.ServiceStub):
    """
    The gNOI service is a collection of operational RPC's that allow for the
    management of a target outside of the configuration and telemetry pipeline.
    """

    async def ping(
        self,
        *,
        destination: str = "",
        source: str = "",
        count: int = 0,
        interval: int = 0,
        wait: int = 0,
        size: int = 0,
        do_not_fragment: bool = False,
        do_not_resolve: bool = False,
        l3_protocol: _types__.L3Protocol = 0,
    ) -> AsyncIterator[PingResponse]:
        """
        Ping executes the ping command on the target and streams back the
        results.  Some targets may not stream any results until all results are
        in.  If a packet count is not explicitly provided, 5 is used.
        """

        request = PingRequest()
        request.destination = destination
        request.source = source
        request.count = count
        request.interval = interval
        request.wait = wait
        request.size = size
        request.do_not_fragment = do_not_fragment
        request.do_not_resolve = do_not_resolve
        request.l3_protocol = l3_protocol

        async for response in self._unary_stream(
            "/gnoi.system.System/Ping", request, PingResponse,
        ):
            yield response

    async def traceroute(
        self,
        *,
        source: str = "",
        destination: str = "",
        initial_ttl: int = 0,
        max_ttl: int = 0,
        wait: int = 0,
        do_not_fragment: bool = False,
        do_not_resolve: bool = False,
        l3_protocol: _types__.L3Protocol = 0,
        l4_protocol: "TracerouteRequestL4Protocol" = 0,
    ) -> AsyncIterator[TracerouteResponse]:
        """
        Traceroute executes the traceroute command on the target and streams
        back the results.  Some targets may not stream any results until all
        results are in.  If a hop count is not explicitly provided, 30 is used.
        """

        request = TracerouteRequest()
        request.source = source
        request.destination = destination
        request.initial_ttl = initial_ttl
        request.max_ttl = max_ttl
        request.wait = wait
        request.do_not_fragment = do_not_fragment
        request.do_not_resolve = do_not_resolve
        request.l3_protocol = l3_protocol
        request.l4_protocol = l4_protocol

        async for response in self._unary_stream(
            "/gnoi.system.System/Traceroute", request, TracerouteResponse,
        ):
            yield response

    async def time(self) -> TimeResponse:
        """
        Time returns the current time on the target.  Time is typically used to
        test if a target is actually responding.
        """

        request = TimeRequest()

        return await self._unary_unary(
            "/gnoi.system.System/Time", request, TimeResponse
        )

    async def set_package(
        self,
        request_iterator: Union[
            AsyncIterable["SetPackageRequest"], Iterable["SetPackageRequest"]
        ],
    ) -> SetPackageResponse:
        """
        SetPackage places a software package (possibly including bootable
        images) on the target. The file is sent in sequential messages, each
        message up to 64KB of data. A final message must be sent that includes
        the hash of the data sent. An error is returned if the location does
        not exist or there is an error writing the data. If no checksum is
        received, the target must assume the operation is incomplete and remove
        the partially transmitted file. The target should initially write the
        file to a temporary location so a failure does not destroy the original
        file.
        """

        return await self._stream_unary(
            "/gnoi.system.System/SetPackage",
            request_iterator,
            SetPackageRequest,
            SetPackageResponse,
        )

    async def switch_control_processor(
        self, *, control_processor: Optional[_types__.Path] = None
    ) -> SwitchControlProcessorResponse:
        """
        SwitchControlProcessor will switch from the current route processor to
        the provided route processor. If the current route processor is the
        same as the one provided it is a NOOP. If the target does not exist an
        error is returned.
        """

        request = SwitchControlProcessorRequest()
        if control_processor is not None:
            request.control_processor = control_processor

        return await self._unary_unary(
            "/gnoi.system.System/SwitchControlProcessor",
            request,
            SwitchControlProcessorResponse,
        )

    async def reboot(
        self,
        *,
        method: "RebootMethod" = 0,
        delay: int = 0,
        message: str = "",
        subcomponents: List[_types__.Path] = [],
        force: bool = False,
    ) -> RebootResponse:
        """
        Reboot causes the target to reboot, possibly at some point in the
        future. If the method of reboot is not supported then the Reboot RPC
        will fail. If the reboot is immediate the command will block until the
        subcomponents have restarted. If a reboot on the active control
        processor is pending the service must reject all other reboot requests.
        If a reboot request for active control processor is initiated with
        other pending reboot requests it must be rejected.
        """

        request = RebootRequest()
        request.method = method
        request.delay = delay
        request.message = message
        if subcomponents is not None:
            request.subcomponents = subcomponents
        request.force = force

        return await self._unary_unary(
            "/gnoi.system.System/Reboot", request, RebootResponse
        )

    async def reboot_status(
        self, *, subcomponents: List[_types__.Path] = []
    ) -> RebootStatusResponse:
        """RebootStatus returns the status of reboot for the target."""

        request = RebootStatusRequest()
        if subcomponents is not None:
            request.subcomponents = subcomponents

        return await self._unary_unary(
            "/gnoi.system.System/RebootStatus", request, RebootStatusResponse
        )

    async def cancel_reboot(
        self, *, message: str = "", subcomponents: List[_types__.Path] = []
    ) -> CancelRebootResponse:
        """CancelReboot cancels any pending reboot request."""

        request = CancelRebootRequest()
        request.message = message
        if subcomponents is not None:
            request.subcomponents = subcomponents

        return await self._unary_unary(
            "/gnoi.system.System/CancelReboot", request, CancelRebootResponse
        )
