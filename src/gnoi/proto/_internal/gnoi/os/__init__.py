# Generated by the protocol buffer compiler.  DO NOT EDIT!
# sources: github.com/openconfig/gnoi/os/os.proto
# plugin: python-betterproto
from dataclasses import dataclass
from typing import AsyncIterable, AsyncIterator, Iterable, Optional, Union

import betterproto
import grpclib


class InstallErrorType(betterproto.Enum):
    UNSPECIFIED = 0
    INCOMPATIBLE = 1
    TOO_LARGE = 2
    PARSE_FAIL = 3
    INTEGRITY_FAIL = 4
    INSTALL_RUN_PACKAGE = 5
    INSTALL_IN_PROGRESS = 6
    UNEXPECTED_SWITCHOVER = 7
    SYNC_FAIL = 8


class ActivateErrorType(betterproto.Enum):
    UNSPECIFIED = 0
    NON_EXISTENT_VERSION = 1


class StandbyStateState(betterproto.Enum):
    UNSPECIFIED = 0
    UNSUPORTED = 1
    NON_EXISTENT = 2
    UNAVAILABLE = 3


@dataclass
class InstallRequest(betterproto.Message):
    transfer_request: "TransferRequest" = betterproto.message_field(1, group="request")
    transfer_content: bytes = betterproto.bytes_field(2, group="request")
    transfer_end: "TransferEnd" = betterproto.message_field(3, group="request")


@dataclass
class TransferRequest(betterproto.Message):
    # The version string is a vendor defined string that identifies the OS
    # version. It is provided by the vendor and embedded in the OS package. This
    # value states the desired OS package version to transfer to the Target. If
    # the Target already has the OS package version it will reply with
    # InstallResponse->Validated. In the case that the target is a single
    # Supervisor device, or the partner Supervisor does not have the OS image
    # specified, it will respond with InstallResponse->TransferReady. In this
    # case, the client MUST subsequently transfer the image. In the case that the
    # image is available on the peer Supervisor of a dual Supervisor system, it
    # will respond with InstallResponse->SyncProgress. In this, latter, case -
    # the client does not need to transfer the OS image. This value can also be
    # set empty, in which case the OS package is forced transferred to the
    # Target. The Target MUST never validate that this value matches the one in
    # the InstallResponse->Validated message, that is the Client's
    # responsibility.
    version: str = betterproto.string_field(1)
    # For a Target with dual Supervisors setting this flag instructs the Target
    # to perform the action on the Standby Supervisor.
    standby_supervisor: bool = betterproto.bool_field(2)


@dataclass
class TransferEnd(betterproto.Message):
    """
    The TransferEnd message is sent whenever the Client finishes transferring
    the OS package to the Target. At this point the Target MUST perform a
    general health check to the OS package. If the Target fails to parse the OS
    package it MUST immediately reply with an InstallError->type->PARSE_FAIL.
    If the integrity check of the OS package fails it MUST immediately reply
    with an InstallError->type->INTEGRITY_FAIL. If the identified OS version
    contained in the package is not compatible with the Target either because
    of the platform type or the running OS, it MUST immediately reply with an
    InstallError->type->INCOMPATIBLE. If the image is force transferred by
    omitting the InstallRequest->TransferRequest->version value, and the OS
    package is the same as the one running in the Target, the RPC MUST
    immediately abort and reply with an
    InstallError->type->INSTALL_RUN_PACKAGE.
    """

    pass


@dataclass
class InstallResponse(betterproto.Message):
    """
    The InstallResponse is used by the Target to inform the Client about the
    state of the Install RPC. At any stage of the process the Target can reply
    with an Error message which MUST terminate the stream.
    """

    transfer_ready: "TransferReady" = betterproto.message_field(1, group="response")
    transfer_progress: "TransferProgress" = betterproto.message_field(
        2, group="response"
    )
    sync_progress: "SyncProgress" = betterproto.message_field(3, group="response")
    validated: "Validated" = betterproto.message_field(4, group="response")
    install_error: "InstallError" = betterproto.message_field(5, group="response")


@dataclass
class TransferReady(betterproto.Message):
    """
    The TransferReady message tells the Client that the Target is ready to
    accept the transfer of the OS package. At this stage the Target MUST have
    cleared enough space to accept the incoming OS package.
    """

    pass


@dataclass
class TransferProgress(betterproto.Message):
    """
    The TransferProgress message is sent by the target asynchronously during a
    file transfer. The device SHOULD not respond to each input block received
    from the client, but rather determine reasonable intervals at which to send
    the message (e.g., 5MB).
    """

    # The number of bytes transferred.
    bytes_received: int = betterproto.uint64_field(1)


@dataclass
class SyncProgress(betterproto.Message):
    """
    The SyncProgress message signals the Client about the progress of
    transferring the OS package between Supervisors.
    """

    # The percentage that has transferred between Supervisors.
    percentage_transferred: int = betterproto.uint32_field(1)


@dataclass
class Validated(betterproto.Message):
    """
    The Validated message asserts that the Target was able to parse the package
    and perform integrity checks to its contents.
    """

    # The OS version string that identifies the OS version in the OS package.
    version: str = betterproto.string_field(1)
    # Informational field that SHOULD be used for providing more details about
    # the OS package and its version. This MUST be strictly informational if
    # used, and can contain information such as build date, target platform,
    # developer, etc.
    description: str = betterproto.string_field(2)


@dataclass
class InstallError(betterproto.Message):
    """
    The InstallError message MUST be sent by the Target to the Client whenever
    an issue occurs. The Target MUST immediately close the RPC without a gRPC
    error.
    """

    type: "InstallErrorType" = betterproto.enum_field(1)
    detail: str = betterproto.string_field(2)


@dataclass
class ActivateRequest(betterproto.Message):
    """
    The ActivateRequest is sent by the Client to the Target to initiate a
    change in the next bootable OS version that is to be used on the Target.
    """

    # The version that is required to be activated and booted.
    version: str = betterproto.string_field(1)
    # For dual Supervisors setting this flag instructs the Target to perform the
    # action on the Standby Supervisor.
    standby_supervisor: bool = betterproto.bool_field(2)


@dataclass
class ActivateResponse(betterproto.Message):
    """
    The ActivateResponse is sent from the Target to the Client in response to
    the Activate RPC. It indicates the success of making the OS package version
    active.
    """

    activate_ok: "ActivateOk" = betterproto.message_field(1, group="response")
    activate_error: "ActivateError" = betterproto.message_field(2, group="response")


@dataclass
class ActivateOk(betterproto.Message):
    """
    If the Target is already running the requested version in ActivateRequest,
    then it replies with ActivateOK. If the Target has the OS package version
    requested in ActivateRequest then it replies with ActivateOK and proceeds
    to boot. In a Target with dual Supervisor, performing this RPC on the
    Active Supervisor triggers a switchover before booting the (old)Active
    Supervisor. The Target should always perform a switchover with the least
    impact possible to forwarding.
    """

    pass


@dataclass
class ActivateError(betterproto.Message):
    type: "ActivateErrorType" = betterproto.enum_field(1)
    detail: str = betterproto.string_field(2)


@dataclass
class VerifyRequest(betterproto.Message):
    pass


@dataclass
class VerifyResponse(betterproto.Message):
    # The OS version currently running.
    version: str = betterproto.string_field(1)
    # Informational message describing fail details of the last boot. This MUST
    # be set when a newly transferred OS fails to boot and the system falls back
    # to the previously running OS version. It MUST be cleared whenever the
    # systems successfully boots the activated OS version.
    activation_fail_message: str = betterproto.string_field(2)
    verify_standby: "VerifyStandby" = betterproto.message_field(3)


@dataclass
class VerifyStandby(betterproto.Message):
    standby_state: "StandbyState" = betterproto.message_field(1, group="state")
    verify_response: "StandbyResponse" = betterproto.message_field(2, group="state")


@dataclass
class StandbyState(betterproto.Message):
    state: "StandbyStateState" = betterproto.enum_field(1)


@dataclass
class StandbyResponse(betterproto.Message):
    # Standby Supervisor ID, usually the slot number.
    id: str = betterproto.string_field(1)
    version: str = betterproto.string_field(2)
    activation_fail_message: str = betterproto.string_field(3)


class OsStub(betterproto.ServiceStub):
    """
    The OS service provides an interface for OS installation on a Target. The
    Client progresses through 3 RPCs:   1) Installation - provide the Target
    with the OS package.   2) Activation - activate an installed OS package.
    3) Verification - verify that the Activation was successful. Dual
    Supervisor Target is supported, where the above process is executed once
    for each Supervisor. Note that certain platforms may have particular
    approaches to upgrade the firmware of specific components, eg., power
    supply units, etc.. In addition, platforms may have processes to apply
    patches to the running OS. Handling these exceptions introduces extra
    complexities. For Targets that implement this service, component firmware
    upgrade or OS patching MUST be embedded within an OS upgrade.
    """

    async def install(
        self,
        request_iterator: Union[
            AsyncIterable["InstallRequest"], Iterable["InstallRequest"]
        ],
    ) -> AsyncIterator[InstallResponse]:
        """
        Install transfers an OS package into the Target. No concurrent Install
        RPCs MUST be allowed to the same Target. The OS package file format is
        platform dependent. The platform MUST validate that the OS package that
        is supplied is valid and bootable. This SHOULD include a hash check
        against a known good hash. It is recommended that the hash is embedded
        in the OS package. The Target manages its own persistent storage, and
        OS installation process. It stores a set of distinct OS packages, and
        always proactively frees up space for incoming new OS packages. It is
        guaranteed that the Target always has enough space for a valid incoming
        OS package. The currently running OS packages MUST never be removed.
        The Client MUST expect that the last successfully installed package is
        available. The Install RPC allows the Client to specify the OS package
        version. If the Target already has an OS package with the same version
        then there is no need to transfer the OS package to the Target. If the
        Target does not have an OS package with the same version, then the OS
        package is copied. Scenario 1 - When the Target already has the OS
        package:         Client :--------------|--------------> Target
        TransferRequest -->                              <--
        [Validated|InstallError] Scenario 2 - When the Target does not have the
        OS package:         Client :--------------|--------------> Target
        TransferRequest -->                              <--
        [TransferReady|InstallError]            transfer_content  -->
        ...                              <-- [TransferProgress|InstallError]
        ...                  TransferEnd -->                              <--
        [Validated|InstallError] On a dual Supervisor Target, only the Active
        Supervisor runs this gNOI Service. The Install RPC applies to the
        Active Supervisor unless
        InstallRequest->TransferRequest->standby_supervisor is set, in which
        case it applies to the Standby Supervisor. One Install RPC is required
        for each Supervisor. The Supervisor order of package installation MUST
        not be fixed. The Target MUST always attempt to copy the OS package
        between Supervisors first before accepting the transfer from the
        Client. The syncing progress is reported to the client with
        InstallResponse->SyncProgress messages. If a switchover is triggered
        during the Install RPC, the RPC MUST immediately abort with
        Error->type->UNEXPECTED_SWITCHOVER. Scenario 3 - When both Supervisors
        already have the OS package, regardless              of the value in
        Start.standby_supervisor:         Client
        :--------------|--------------> Target              TransferRequest -->
        <-- [Validated|InstallError] Scenario 4 - When one of the Supervisors
        already has the OS package but the              other Supervisor is the
        target of the Install:         Client :--------------|-------------->
        Target              TransferRequest -->
        <-- [SyncProgress|InstallError]                              ...
        <-- [Validated|InstallError] Scenario 5 - When neither of the two
        Supervisors has the OS package:         Client
        :--------------|--------------> Target              TransferRequest -->
        <-- [TransferReady|InstallError]            transfer_content  -->
        ...                              <-- [TransferProgress|InstallError]
        ...                  TransferEnd -->                              <--
        [Validated|InstallError]
        """

        async for response in self._stream_stream(
            "/gnoi.os.OS/Install", request_iterator, InstallRequest, InstallResponse,
        ):
            yield response

    async def activate(
        self, *, version: str = "", standby_supervisor: bool = False
    ) -> ActivateResponse:
        """
        Activate sets the requested OS version as the version which is used at
        the next reboot, and reboots the Target. When booting the requested OS
        version fails, the Target recovers by booting the previously running OS
        package.
        """

        request = ActivateRequest()
        request.version = version
        request.standby_supervisor = standby_supervisor

        return await self._unary_unary(
            "/gnoi.os.OS/Activate", request, ActivateResponse
        )

    async def verify(self) -> VerifyResponse:
        """
        Verify checks the running OS version. This RPC may be called multiple
        times while the Target boots, until successful.
        """

        request = VerifyRequest()

        return await self._unary_unary("/gnoi.os.OS/Verify", request, VerifyResponse)
