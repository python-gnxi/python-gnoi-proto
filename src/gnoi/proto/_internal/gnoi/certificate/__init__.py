# Generated by the protocol buffer compiler.  DO NOT EDIT!
# sources: github.com/openconfig/gnoi/cert/cert.proto
# plugin: python-betterproto
from dataclasses import dataclass
from typing import AsyncIterable, AsyncIterator, Iterable, List, Optional, Union

import betterproto
import grpclib


class CertificateType(betterproto.Enum):
    """Types of certificates."""

    # 1 - 500 for public use. 501 onwards for private use.
    CT_UNKNOWN = 0
    CT_X509 = 1


class KeyType(betterproto.Enum):
    """Algorithm to be used for generation the key pair."""

    # 1 - 500, for known types. 501 and onwards for private use.
    KT_UNKNOWN = 0
    KT_RSA = 1


class EndpointType(betterproto.Enum):
    EP_UNSPECIFIED = 0
    EP_IPSEC_TUNNEL = 1
    EP_DAEMON = 2


@dataclass
class RotateCertificateRequest(betterproto.Message):
    """Request messages to rotate existing certificates on the target."""

    generate_csr: "GenerateCsrRequest" = betterproto.message_field(
        1, group="rotate_request"
    )
    load_certificate: "LoadCertificateRequest" = betterproto.message_field(
        2, group="rotate_request"
    )
    finalize_rotation: "FinalizeRequest" = betterproto.message_field(
        3, group="rotate_request"
    )


@dataclass
class RotateCertificateResponse(betterproto.Message):
    """Response Messages from the target."""

    generated_csr: "GenerateCsrResponse" = betterproto.message_field(
        1, group="rotate_response"
    )
    load_certificate: "LoadCertificateResponse" = betterproto.message_field(
        2, group="rotate_response"
    )


@dataclass
class InstallCertificateRequest(betterproto.Message):
    """Request messages to install new certificates on the target."""

    generate_csr: "GenerateCsrRequest" = betterproto.message_field(
        1, group="install_request"
    )
    load_certificate: "LoadCertificateRequest" = betterproto.message_field(
        2, group="install_request"
    )


@dataclass
class InstallCertificateResponse(betterproto.Message):
    """Response Messages from the target for the InstallCertificateRequest."""

    generated_csr: "GenerateCsrResponse" = betterproto.message_field(
        1, group="install_response"
    )
    load_certificate: "LoadCertificateResponse" = betterproto.message_field(
        2, group="install_response"
    )


@dataclass
class GenerateCsrRequest(betterproto.Message):
    """
    Request to generate the CSR. When this request is made for rotating an
    existing certificate as part of the Rotate() RPC, then the target must
    ensure that the "certificate_id" is already created and exists on the
    target. If the Certificate Rotation proceeds to load the certificate, it
    must associate the new certificate with the previously created
    "certificate_id". When this request is made for installing a completely new
    certificate as part of the Install() RPC , then the target must ensure that
    the "certificate_id" is completely new and no entities on the target are
    should be bound to this certificate_id. If any existing certificate matches
    the certificate_id, then this request should fail. If there is another
    ongoing Rotate/Install RPC with the same certificate_id, the
    GenerateCSRRequest should fail.
    """

    # Parameters for creating a CSR.
    csr_params: "CsrParams" = betterproto.message_field(1)
    # The certificate id with which this CSR will be associated. The target
    # configuration should bind an entity which wants to use a certificate to the
    # certificate_id it should use.
    certificate_id: str = betterproto.string_field(2)


@dataclass
class CsrParams(betterproto.Message):
    """Parameters to be used when generating a Certificate Signing Request."""

    # The type of certificate which will be associated for this CSR.
    type: "CertificateType" = betterproto.enum_field(1)
    # Minimum size of the key to be used by the target when generating a
    # public/private key pair.
    min_key_size: int = betterproto.uint32_field(2)
    # If provided, the target must use the provided key type. If the target
    # cannot use the algorithm specified in the key_type, it should cancel the
    # stream with an Unimplemented error.
    key_type: "KeyType" = betterproto.enum_field(3)
    # --- common set of parameters applicable for any type of certificate --- //
    common_name: str = betterproto.string_field(4)
    country: str = betterproto.string_field(5)
    state: str = betterproto.string_field(6)
    city: str = betterproto.string_field(7)
    organization: str = betterproto.string_field(8)
    organizational_unit: str = betterproto.string_field(9)
    ip_address: str = betterproto.string_field(10)
    email_id: str = betterproto.string_field(11)


@dataclass
class GenerateCsrResponse(betterproto.Message):
    """
    GenerateCSRResponse contains the CSR associated with the Certificate ID
    supplied in the GenerateCSRRequest. When a Certificate is subsequently
    installed on the target in the same streaming RPC session, it must be
    associated to that Certificate ID. An Unimplemented error will be returned
    if the target cannot generate a CSR as per the request. In this case, the
    caller must generate its own key pair.
    """

    csr: "Csr" = betterproto.message_field(1)


@dataclass
class LoadCertificateRequest(betterproto.Message):
    """
    LoadCertificateRequest instructs the target to store the given certificate.
    Case 1: Target Generated CSR and Key Pair. If the target generated the CSR
    (and the public/private key pair) during the GenerateCSR request, then the
    target must associate the certificate with the certificate ID specified in
    the preceding GenerateCSR request. Case 2: Externally Generated Key Pair.
    If the target can not generate a CSR, then the public/private key pair is
    generated externally. In this case provide the target with the key pair,
    and the certificate_id to be associated with the new certificate. If there
    is another ongoing Rotate/Install RPC with the same certificate_id, the
    LoadCertificateRequest must fail.
    """

    # The certificate to be Loaded on the target.
    certificate: "Certificate" = betterproto.message_field(1)
    # The key pair to be used with the certificate. This is provided in the event
    # that the target cannot generate a CSR (and the corresponding public/private
    # keys).
    key_pair: "KeyPair" = betterproto.message_field(2)
    # Certificate Id of the above certificate. This is to be provided only when
    # there is an externally generated key pair.
    certificate_id: str = betterproto.string_field(3)
    # Optional bundle of CA certificates. When not empty, the provided
    # certificates should squash the existing bundle. This field provides a
    # simplified means to provision a CA bundle that can be used to validate
    # other peer's certificates. To improve performance in the Target,
    # certificates can be ordered. Groups of chained certificates should be last,
    # where within, the root certificate is the last one. E.g.: CertA, CertB,
    # CertB-Root, CertC, CertC-Intermediate, CertC-Root Note that on a forward
    # looking iteration, CA Certificates will be managed by a dedicated gNOI
    # service.
    ca_certificates: List["Certificate"] = betterproto.message_field(4)


@dataclass
class LoadCertificateResponse(betterproto.Message):
    """
    Response from target after Loading a Certificate. If the target could not
    load the certificate, it must end the RPC stream with a suitable RPC error
    about why the Certificate was not loaded.
    """

    pass


@dataclass
class FinalizeRequest(betterproto.Message):
    """
    A Finalize message is sent to the target to confirm the Rotation of the
    certificate and that the certificate should not be rolled back when the RPC
    concludes. The certificate must be rolled back if the target returns an
    error after receiving a Finalize message.
    """

    pass


@dataclass
class GetCertificatesRequest(betterproto.Message):
    """The request to query all the certificates on the target."""

    pass


@dataclass
class GetCertificatesResponse(betterproto.Message):
    """
    Response from the target about the certificates that exist on the target
    what what is using them.
    """

    certificate_info: List["CertificateInfo"] = betterproto.message_field(1)


@dataclass
class CertificateInfo(betterproto.Message):
    certificate_id: str = betterproto.string_field(1)
    certificate: "Certificate" = betterproto.message_field(2)
    # List of endpoints using this certificate.
    endpoints: List["Endpoint"] = betterproto.message_field(3)
    # System modification time when the certificate was installed/rotated in
    # nanoseconds since epoch.
    modification_time: int = betterproto.int64_field(4)


@dataclass
class RevokeCertificatesRequest(betterproto.Message):
    # Certificates to revoke.
    certificate_id: List[str] = betterproto.string_field(1)


@dataclass
class RevokeCertificatesResponse(betterproto.Message):
    # List of certificates successfully revoked.
    revoked_certificate_id: List[str] = betterproto.string_field(1)
    # List of errors why certain certificates could not be revoked.
    certificate_revocation_error: List[
        "CertificateRevocationError"
    ] = betterproto.message_field(2)


@dataclass
class CertificateRevocationError(betterproto.Message):
    """
    An error message indicating why a certificate id could not be revoked.
    """

    certificate_id: str = betterproto.string_field(1)
    error_message: str = betterproto.string_field(2)


@dataclass
class CanGenerateCsrRequest(betterproto.Message):
    """A request to ask the target if it can generate key pairs."""

    key_type: "KeyType" = betterproto.enum_field(1)
    certificate_type: "CertificateType" = betterproto.enum_field(2)
    key_size: int = betterproto.uint32_field(3)


@dataclass
class CanGenerateCsrResponse(betterproto.Message):
    """
    Response from the target about whether it can generate a CSR with the given
    parameters.
    """

    can_generate: bool = betterproto.bool_field(4)


@dataclass
class Certificate(betterproto.Message):
    """A certificate."""

    # Type of certificate.
    type: "CertificateType" = betterproto.enum_field(1)
    # Actual certificate. The exact encoding depends upon the type of
    # certificate. for X509, this should be a PEM encoded Certificate.
    certificate: bytes = betterproto.bytes_field(2)


@dataclass
class Csr(betterproto.Message):
    """A Certificate Signing Request."""

    # Type of certificate.
    type: "CertificateType" = betterproto.enum_field(1)
    # Bytes representing the CSR. The exact encoding depends upon the type of
    # certificate requested. for X509: This should be the PEM encoded CSR.
    csr: bytes = betterproto.bytes_field(2)


@dataclass
class KeyPair(betterproto.Message):
    """A message representing a pair of public/private keys."""

    private_key: bytes = betterproto.bytes_field(1)
    public_key: bytes = betterproto.bytes_field(2)


@dataclass
class Endpoint(betterproto.Message):
    """
    An endpoint represents an entity on the target which can use a certificate.
    """

    type: "EndpointType" = betterproto.enum_field(1)
    # Human readable identifier for an endpoint.
    endpoint: str = betterproto.string_field(2)


class CertificateManagementStub(betterproto.ServiceStub):
    """
    The Certificate Management Service exported by targets. The service
    primarily exports two main RPCs, Install & Rotate which are used for
    installation of a new certificate, and rotation of an existing certificate
    on a target, along with a few management related RPCs.
    """

    async def rotate(
        self,
        request_iterator: Union[
            AsyncIterable["RotateCertificateRequest"],
            Iterable["RotateCertificateRequest"],
        ],
    ) -> AsyncIterator[RotateCertificateResponse]:
        """
        Rotate will replace an existing Certificate on the target by creating a
        new CSR request and placing the new Certificate based on the CSR on the
        target. If the stream is broken or any steps in the process fail the
        target must rollback to the original Certificate. The following
        describes the sequence of messages that must be exchanged in the
        Rotate() RPC. Sequence of expected messages: Case 1: When Target
        generates the CSR.   Step 1: Start the stream     Client <---- Rotate()
        RPC stream begin ------> Target   Step 2: CSR     Client ----->
        GenerateCSRRequest----> Target     Client <----- GenerateCSRResponse
        <--- Target   Step 3: Certificate Signing     Client gets the
        certificate signed by the CA.   Step 4: Send Certificate to Target.
        Client --> LoadCertificateRequest ----> Target     Client <--
        LoadCertificateResponse <--- Target   Step 5: Test/Validation by the
        client.     This step should be to create a new connection to the
        target using     The new certificate and validate that the certificate
        works.     Once verfied, the client will then proceed to finalize the
        rotation.     If the new connection cannot be completed the client will
        cancel the     RPC thereby forcing the target to rollback the
        certificate.   Step 6: Final commit.     Client ---> FinalizeRequest
        ----> Target Case 2: When Client generates the CSR.   Step 1: Start the
        stream     Client <---- Rotate() RPC stream begin ----> Target   Step
        2: CSR     Client generates its own certificate.   Step 3: Certificate
        Signing     Client gets the certificate signed by the CA.   Step 4:
        Send Certificate to Target.     Client ---> LoadCertificateRequest
        ----> Target     Client <--- LoadCertificateResponse <--- Target   Step
        5: Test/Validation by the client.   Step 6: Final commit.     Client
        ---> FinalizeRequest ----> Target
        """

        async for response in self._stream_stream(
            "/gnoi.certificate.CertificateManagement/Rotate",
            request_iterator,
            RotateCertificateRequest,
            RotateCertificateResponse,
        ):
            yield response

    async def install(
        self,
        request_iterator: Union[
            AsyncIterable["InstallCertificateRequest"],
            Iterable["InstallCertificateRequest"],
        ],
    ) -> AsyncIterator[InstallCertificateResponse]:
        """
        Install will put a new Certificate on the target by creating a new CSR
        request and placing the new Certificate based on the CSR on the
        target.The new Certificate will be associated with a new Certificate Id
        on the target. If the target has a pre existing Certificate with the
        given Certificate Id, the operation should fail. If the stream is
        broken or any steps in the process fail the target must revert any
        changes in state. The following describes the sequence of messages that
        must be exchanged in the Install() RPC. Sequence of expected messages:
        Case 1: When Target generates the CSR-------------------------:   Step
        1: Start the stream     Client <---- Install() RPC stream begin ------>
        Target   Step 2: CSR     Client -----> GenerateCSRRequest() ---->
        Target     Client <---- GenerateCSRResponse() <---- Target   Step 3:
        Certificate Signing     Client gets the certificate signed by the CA.
        Step 4: Send Certificate to Target.     Client ->
        LoadCertificateRequest() ----> Target     Client <-
        LoadCertificateResponse() <--- Target Case 2: When Client generates the
        CSR-------------------------:   Step 1: Start the stream     Client
        <---- Install() RPC stream begin ------> Target   Step 2: CSR
        Client generates its own certificate.   Step 3: Certificate Signing
        Client gets the certificate signed by the CA.   Step 4: Send
        Certificate to Target.     Client -> LoadCertificateRequest() ---->
        Target     Client <- LoadCertificateResponse() <--- Target
        """

        async for response in self._stream_stream(
            "/gnoi.certificate.CertificateManagement/Install",
            request_iterator,
            InstallCertificateRequest,
            InstallCertificateResponse,
        ):
            yield response

    async def get_certificates(self) -> GetCertificatesResponse:
        """An RPC to get the certificates on the target."""

        request = GetCertificatesRequest()

        return await self._unary_unary(
            "/gnoi.certificate.CertificateManagement/GetCertificates",
            request,
            GetCertificatesResponse,
        )

    async def revoke_certificates(
        self, *, certificate_id: List[str] = []
    ) -> RevokeCertificatesResponse:
        """
        An RPC to revoke specific certificates. If a certificate is not present
        on the target, the request should silently succeed. Revoking a
        certificate should render the existing certificate unusable by any
        endpoints.
        """

        request = RevokeCertificatesRequest()
        request.certificate_id = certificate_id

        return await self._unary_unary(
            "/gnoi.certificate.CertificateManagement/RevokeCertificates",
            request,
            RevokeCertificatesResponse,
        )

    async def can_generate_csr(self) -> CanGenerateCsrResponse:
        """An RPC to ask a target if it can generate a Certificate."""

        request = CanGenerateCsrRequest()

        return await self._unary_unary(
            "/gnoi.certificate.CertificateManagement/CanGenerateCSR",
            request,
            CanGenerateCsrResponse,
        )
